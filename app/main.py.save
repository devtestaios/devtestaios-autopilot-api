from fastapi import FastAPIfrom fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware from typing import Optional import os import httpx from fastapi.middleware.cors import 
CORSMiddleware app = FastAPI(title="Autopilot API", version="0.1.0") from typing import Optional import os# CORS: allow your Vercel app and local dev app.add_middleware( import httpx 
CORSMiddleware,
    allow_origin_regex=r"https://.*\.vercel\.app$", app = FastAPI(title="Autopilot API", version="0.1.0") allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],
    allow_credentials=True,
# CORS: allow your Vercel app and local dev allow_methods=["*"],
app.add_middleware( allow_headers=["*"], )
    CORSMiddleware, @app.get("/") def root():
    allow_origin_regex=r"https://.*\.vercel\.app$", return {"status": "ok", "msg": "Autopilot API root"}
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"], from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware from typing import Optional import os import 
httpx
    allow_credentials=True, app = FastAPI(title="Autopilot API", version="0.1.0")
    allow_methods=["*"],
    allow_headers=["*"],# CORS: allow your Vercel app and local dev app.add_middleware( ) CORSMiddleware,
    allow_origin_regex=r"https://.*\.vercel\.app$", @app.get("/") allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"], def root(): allow_credentials=True,
    return {"status": "ok", "msg": "Autopilot API root"} allow_methods=["*"],
    allow_headers=["*"], ) @app.get("/health") @app.get("/") def root(): def health(): return {"status": "ok", "msg": "Autopilot API root"}
    return {"ok": True} @app.get("/health") def health():
    return {"ok": True} @app.get("/version") @app.get("/version") def version(): def version(): return {"version": app.version}
    return {"version": app.version} @app.get("/_routes") def list_routes():
    # Show the paths the server currently exposes
@app.get("/_routes") paths = sorted({r.path for r in app.routes}) def list_routes(): return {"routes": paths}
    # Show the paths the server currently exposes
    paths = sorted({r.path for r in app.routes})@app.get("/env-check") def env_check():
    return {"routes": paths} # We read the public Supabase vars (these are what your frontend uses)
    return { @app.get("/env-check") "SUPABASE_URL_present": bool(os.getenv("NEXT_PUBLIC_SUPABASE_URL")), def env_check(): "SUPABASE_ANON_KEY_present": 
bool(os.getenv("NEXT_PUBLIC_SUPABASE_ANON_KEY")),
    # We read the public Supabase vars (these are what your frontend uses)
    return {
        "SUPABASE_URL_present": bool(os.getenv("NEXT_PUBLIC_SUPABASE_URL")),
        "SUPABASE_ANON_KEY_present": bool(os.getenv("NEXT_PUBLIC_SUPABASE_ANON_KEY")),
    }

@app.get("/test-db")
def test_db():
    """
    Check Supabase reachability using the public anon key.
    Works if NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are set on the server.
    """
    base = (os.getenv("NEXT_PUBLIC_SUPABASE_URL") or "").rstrip("/")
    key = os.getenv("NEXT_PUBLIC_SUPABASE_ANON_KEY")
    if not base or not key:
        return {"ok": False, "error": "Missing Supabase envs on server"}

    # Try both known endpoints (some projects prefer /settings, some /info)
    candidates = [f"{base}/auth/v1/settings", f"{base}/auth/v1/info"]
    tried = []

    for url in candidates:
        try:
            r = httpx.get(url, headers={"apikey": key, "Authorization": f"Bearer {key}"}, timeout=8.0)
            tried.append({"url": url, "status": r.status_code})
            if r.status_code == 200:
                return {"ok": True, "status": r.status_code, "url": url}
        except Exception as e:
            tried.append({"url": url, "error": str(e)})

    return {"ok": False, "tried": tried    }

@app.get("/test-db")
def test_db():
    """
    Check Supabase reachability using the public anon key.
    Works if NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are set on the server.
    """
    base = (os.getenv("NEXT_PUBLIC_SUPABASE_URL") or "").rstrip("/")
    key = os.getenv("NEXT_PUBLIC_SUPABASE_ANON_KEY")
    if not base or not key:
        return {"ok": False, "error": "Missing Supabase envs on server"}

    # Try both known endpoints (some projects prefer /settings, some /info)
    candidates = [f"{base}/auth/v1/settings", f"{base}/auth/v1/info"]
    tried = []

    for url in candidates:
        try:
            r = httpx.get(url, headers={"apikey": key, "Authorization": f"Bearer {key}"}, timeout=8.0)
            tried.append({"url": url, "status": r.status_code})
            if r.status_code == 200:
                return {"ok": True, "status": r.status_code, "url": url}
        except Exception as e:
            tried.append({"url": url, "error": str(e)})

    return {"ok": False, "tried": tried}
@app.get("/health")
def health():
    return {"ok": True}

@app.get("/version")
def version():
    return {"version": app.version}

@app.get("/_routes")
def list_routes():
    # Show the paths the server currently exposes
    paths = sorted({r.path for r in app.routes})
    return {"routes": paths}

@app.get("/env-check")
def env_check():
    # We read the public Supabase vars (these are what your frontend uses)
    return {
        "SUPABASE_URL_present": bool(os.getenv("NEXT_PUBLIC_SUPABASE_URL")),
        "SUPABASE_ANON_KEY_present": bool(os.getenv("NEXT_PUBLIC_SUPABASE_ANON_KEY")),
    }

@app.get("/test-db")
def test_db():
    """
    Check Supabase reachability using the public anon key.
    Works if NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are set on the server.
    """
    base = (os.getenv("NEXT_PUBLIC_SUPABASE_URL") or "").rstrip("/")
    key = os.getenv("NEXT_PUBLIC_SUPABASE_ANON_KEY")
    if not base or not key:
        return {"ok": False, "error": "Missing Supabase envs on server"}

    # Try both known endpoints (some projects prefer /settings, some /info)
    candidates = [f"{base}/auth/v1/settings", f"{base}/auth/v1/info"]
    tried = []

    for url in candidates:
        try:
            r = httpx.get(url, headers={"apikey": key, "Authorization": f"Bearer {key}"}, timeout=8.0)
            tried.append({"url": url, "status": r.status_code})
            if r.status_code == 200:
                return {"ok": True, "status": r.status_code, "url": url}
        except Exception as e:
            tried.append({"url": url, "error": str(e)})

    return {"ok": False, "tried": tried}
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr
from typing import Optional
import os
import httpx

app = FastAPI(title="Autopilot API", version="0.1.0")

# Allow frontend (vercel) to call backend (render)
app.add_middleware(
    CORSMiddleware,
    allow_origin_regex=r"https://.*\.vercel\.app$",
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Root route
@app.get("/")
def root():
    return {"status": "ok", "msg": "Autopilot API root"}

# Health check
@app.get("/health")
def health():
    return {"ok": True}

# List all routes
@app.get("/_routes")
def routes():
    return {"routes": [r.path for r in app.routes]}

# Version endpoint
@app.get("/version")
def version():
    return {"version": app.version}

# Environment variable check
@app.get("/env-check")
def env_check():
    return {
        "SUPABASE_URL_present": bool(os.getenv("SUPABASE_URL")),
        "SUPABASE_ANON_KEY_present": bool(os.getenv("SUPABASE_ANON_KEY")),
    }

# Test DB connection
@app.get("/test-db")
async def test_db():
    url = os.getenv("SUPABASE_URL")
    key = os.getenv("SUPABASE_ANON_KEY")
    if not url or not key:
        return {"ok": False, "error": "Missing SUPABASE_URL or SUPABASE_ANON_KEY"}

    info_url = url.rstrip("/") + "/auth/v1/settings"
    try:
        async with httpx.AsyncClient(timeout=10) as client:
            r = await client.get(info_url, headers={"apikey": key})
            return {"ok": r.status_code == 200, "status": r.status_code, "url": info_url}
    except Exception as e:
        return {"ok": False, "error": str(e)}

# Example Lead model (safe for Python 3.8)
class LeadIn(BaseModel):
    email: EmailStr
    name: Optional[str] = None

