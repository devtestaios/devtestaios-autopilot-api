"""
Attribution Model Base Classes and Results
Foundation for Shapley, Markov, and other attribution models
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Optional, Any
from datetime import datetime
from pydantic import BaseModel, Field
from enum import Enum

from app.attribution.event_schema import CustomerJourney, Platform, TouchpointEvent


class AttributionModelType(str, Enum):
    """Types of attribution models"""
    # Simple models
    LAST_CLICK = "last_click"
    FIRST_CLICK = "first_click"
    LINEAR = "linear"
    TIME_DECAY = "time_decay"
    POSITION_BASED = "position_based"

    # AI-powered models
    SHAPLEY = "shapley"  # Game theory approach
    MARKOV = "markov"    # Probabilistic approach
    DATA_DRIVEN = "data_driven"  # ML-based


class PlatformAttribution(BaseModel):
    """Attribution credit assigned to a platform"""
    platform: Platform
    credit: float = Field(..., description="Attribution credit (0-1, sum to 1)")
    touchpoint_count: int = Field(..., description="Number of touchpoints")
    revenue_attributed: float = Field(0.0, description="Revenue attributed to platform")
    cost: Optional[float] = Field(None, description="Cost of platform campaigns")
    roi: Optional[float] = Field(None, description="ROI = revenue / cost")


class CampaignAttribution(BaseModel):
    """Attribution credit assigned to a specific campaign"""
    campaign_id: str
    campaign_name: Optional[str] = None
    platform: Platform
    credit: float = Field(..., description="Attribution credit (0-1)")
    touchpoint_count: int = Field(..., description="Number of touchpoints from campaign")
    revenue_attributed: float = Field(0.0, description="Revenue attributed")
    cost: Optional[float] = Field(None, description="Campaign cost")
    roas: Optional[float] = Field(None, description="ROAS = revenue / cost")

    # Touchpoint positions
    first_touch_count: int = Field(0, description="Times campaign was first touch")
    last_touch_count: int = Field(0, description="Times campaign was last touch")
    middle_touch_count: int = Field(0, description="Times campaign was middle touch")


class AttributionResult(BaseModel):
    """
    Result of attribution analysis for a single journey or cohort

    Contains attribution credits for platforms, campaigns, and insights
    """
    # Journey info
    journey_id: Optional[str] = Field(None, description="Specific journey ID")
    user_id: Optional[str] = Field(None, description="User ID")
    cohort_id: Optional[str] = Field(None, description="Cohort identifier")

    # Attribution model used
    model_type: AttributionModelType = Field(..., description="Which model was used")
    model_version: str = Field("1.0.0", description="Model version")

    # Results
    platform_attribution: List[PlatformAttribution] = Field(
        default_factory=list,
        description="Credit by platform"
    )
    campaign_attribution: List[CampaignAttribution] = Field(
        default_factory=list,
        description="Credit by campaign"
    )

    # Conversion info
    converted: bool = Field(..., description="Whether journey converted")
    conversion_value: float = Field(0.0, description="Total conversion value")
    conversion_date: Optional[datetime] = Field(None)

    # Journey stats
    total_touchpoints: int = Field(..., description="Total touchpoints in journey")
    unique_platforms: int = Field(..., description="Number of different platforms")
    days_to_convert: Optional[float] = Field(None, description="Days from first touch")

    # Model confidence
    confidence_score: float = Field(
        0.0,
        description="Model confidence (0-1), higher = more certain"
    )

    # Insights (generated by model)
    insights: List[str] = Field(
        default_factory=list,
        description="Human-readable insights about attribution"
    )

    # Timestamp
    analyzed_at: datetime = Field(default_factory=lambda: datetime.now())

    def get_platform_credit(self, platform: Platform) -> float:
        """Get attribution credit for a specific platform"""
        for pa in self.platform_attribution:
            if pa.platform == platform:
                return pa.credit
        return 0.0

    def get_top_platforms(self, n: int = 3) -> List[PlatformAttribution]:
        """Get top N platforms by attribution credit"""
        return sorted(
            self.platform_attribution,
            key=lambda x: x.credit,
            reverse=True
        )[:n]

    def get_top_campaigns(self, n: int = 5) -> List[CampaignAttribution]:
        """Get top N campaigns by attribution credit"""
        return sorted(
            self.campaign_attribution,
            key=lambda x: x.credit,
            reverse=True
        )[:n]


class AttributionModel(ABC):
    """
    Abstract base class for attribution models

    All attribution models (Shapley, Markov, etc.) inherit from this
    """

    model_type: AttributionModelType
    model_version: str = "1.0.0"

    @abstractmethod
    def calculate_attribution(
        self,
        journey: CustomerJourney
    ) -> AttributionResult:
        """
        Calculate attribution for a single journey

        Args:
            journey: Customer journey with touchpoints and conversion

        Returns:
            AttributionResult with credit assigned to touchpoints
        """
        pass

    def calculate_batch_attribution(
        self,
        journeys: List[CustomerJourney]
    ) -> List[AttributionResult]:
        """
        Calculate attribution for multiple journeys

        Default implementation just loops. Subclasses can override
        for batch optimization.
        """
        return [self.calculate_attribution(j) for j in journeys]

    def _generate_platform_attribution(
        self,
        journey: CustomerJourney,
        touchpoint_credits: Dict[int, float]  # index -> credit
    ) -> List[PlatformAttribution]:
        """
        Helper: Aggregate touchpoint credits by platform

        Args:
            journey: Customer journey
            touchpoint_credits: Dict mapping touchpoint index to credit

        Returns:
            List of PlatformAttribution
        """
        platform_data: Dict[Platform, Dict[str, Any]] = {}

        for idx, touchpoint in enumerate(journey.touchpoints):
            credit = touchpoint_credits.get(idx, 0.0)

            if touchpoint.platform not in platform_data:
                platform_data[touchpoint.platform] = {
                    "credit": 0.0,
                    "count": 0,
                    "revenue": 0.0
                }

            platform_data[touchpoint.platform]["credit"] += credit
            platform_data[touchpoint.platform]["count"] += 1

            # Attribute revenue proportionally
            if journey.conversion:
                platform_data[touchpoint.platform]["revenue"] += (
                    credit * journey.conversion.revenue
                )

        # Convert to PlatformAttribution objects
        result = []
        for platform, data in platform_data.items():
            result.append(PlatformAttribution(
                platform=platform,
                credit=data["credit"],
                touchpoint_count=data["count"],
                revenue_attributed=data["revenue"]
            ))

        return result

    def _generate_campaign_attribution(
        self,
        journey: CustomerJourney,
        touchpoint_credits: Dict[int, float]
    ) -> List[CampaignAttribution]:
        """
        Helper: Aggregate touchpoint credits by campaign

        Args:
            journey: Customer journey
            touchpoint_credits: Dict mapping touchpoint index to credit

        Returns:
            List of CampaignAttribution
        """
        campaign_data: Dict[str, Dict[str, Any]] = {}

        for idx, touchpoint in enumerate(journey.touchpoints):
            if not touchpoint.campaign_id:
                continue

            credit = touchpoint_credits.get(idx, 0.0)
            campaign_id = touchpoint.campaign_id

            if campaign_id not in campaign_data:
                campaign_data[campaign_id] = {
                    "campaign_name": touchpoint.campaign_name,
                    "platform": touchpoint.platform,
                    "credit": 0.0,
                    "count": 0,
                    "revenue": 0.0,
                    "first_touch": 0,
                    "last_touch": 0,
                    "middle_touch": 0
                }

            campaign_data[campaign_id]["credit"] += credit
            campaign_data[campaign_id]["count"] += 1

            if journey.conversion:
                campaign_data[campaign_id]["revenue"] += (
                    credit * journey.conversion.revenue
                )

            # Track position
            if idx == 0:
                campaign_data[campaign_id]["first_touch"] += 1
            elif idx == len(journey.touchpoints) - 1:
                campaign_data[campaign_id]["last_touch"] += 1
            else:
                campaign_data[campaign_id]["middle_touch"] += 1

        # Convert to CampaignAttribution objects
        result = []
        for campaign_id, data in campaign_data.items():
            result.append(CampaignAttribution(
                campaign_id=campaign_id,
                campaign_name=data["campaign_name"],
                platform=data["platform"],
                credit=data["credit"],
                touchpoint_count=data["count"],
                revenue_attributed=data["revenue"],
                first_touch_count=data["first_touch"],
                last_touch_count=data["last_touch"],
                middle_touch_count=data["middle_touch"]
            ))

        return result

    def _calculate_confidence(
        self,
        journey: CustomerJourney
    ) -> float:
        """
        Calculate confidence score for attribution

        Higher confidence when:
        - More touchpoints (more data)
        - Longer journey (clearer path)
        - Converted (we have outcome)
        """
        confidence = 0.5  # Base confidence

        # More touchpoints = higher confidence
        touchpoint_score = min(journey.total_touchpoints / 10.0, 0.3)
        confidence += touchpoint_score

        # Conversions give more confidence (we know the outcome)
        if journey.converted:
            confidence += 0.2

        # Longer journeys (more data points)
        if journey.days_to_convert and journey.days_to_convert > 7:
            confidence += 0.1

        return min(confidence, 1.0)
